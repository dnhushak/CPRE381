DEPTH=1024; 	% Memory depth and width are required 
		% DEPTH is the number of addresses 
WIDTH = 32; 	% WIDTH is the number of bits of data per word
		% DEPTH and WIDTH should be entered as decimal numbers

ADDRESS_RADIX = DEC; 	% Address and value radixes are required
DATA_RADIX = BIN; 	% Enter BIN, DEC, HEX, OCT, or UNS; unless
			% otherwise specified, radixes = HEX

-- Specify values for addresses, which can be single address or range
-- SOME THINGS TO CONSIDER
-- 1) This memory is word-addressable, versus the MIPS conceptual byte-addressable memory.
--    This means that address 1 corresponds to word 1, address 2 corresponds to word 2, etc.
--    Since MIPS will be generating byte addresses, you will have to create some (very simple)
--    logic in your VHDL wrapper to deal with byte/word offsets. 
-- 2) The "single address" notation seems to be least likely to cause confusion so that is what
--    I recommend. 
-- 3) The values need to be in 32-bit hex form (i.e. don't use F when you really mean 0000000F).

-- Sample C code:
--   if (a != b) c = a + b;
-- Assume a @ 0x0000($zero), b @ 0x0004($zero), c @ 0x0008($zero0
-- Assembly code:

CONTENT
BEGIN
-- Instruction formats
--R ======-----=====-----=====------
--I ======-----=====----------------
--J ======--------------------------
0 : 00100011101111011111111111101100
1 : 10101111101111110000000000010000
2 : 10101111101100110000000000001100
3 : 10101111101100100000000000001000
4 : 10101111101100010000000000000100
5 : 10101111101100000000000000000000
6 : 00100000100100100000000000000000
7 : 00100000101100110000000000000000
8 : 00100000000100000000000000000000
9 : 00000010000100110100000000101010
10 : 00010001000000000000000000010000
11 : 00100010000100011111111111111111
12 : 00101010001010000000000000000000
13 : 00010101000000000000000000001011
14 : 00000000000100010100100010000000
15 : 00000010010010010101000000100000
16 : 10001101010010110000000000000000
17 : 10001101010011000000000000000100
18 : 00000001100010110100000000101010
19 : 00010001000000000000000000000101
20 : 00100010010001000000000000000000
21 : 00100010001001010000000000000000
22 : 00001100000100000000000000100010
23 : 00100010001100011111111111111111
24 : 00001000000100000000000000001100
25 : 00100010000100000000000000000001
26 : 00001000000100000000000000001001
27 : 10001111101100000000000000000000
28 : 10001111101100010000000000000100
29 : 10001111101100100000000000001000
30 : 10001111101100110000000000001100
31 : 10001111101111110000000000010000
32 : 00100011101111010000000000010100
33 : 00000011111000000000000000001000
34 : 00000000000001010100100010000000
35 : 00000000100010010100100000100000
36 : 10001101001010000000000000000000
37 : 10001101001010100000000000000100
38 : 10101101001010100000000000000000
39 : 10101101001010000000000000000100
40 : 00000011111000000000000000001000
[41..63] : 00000000; 			
END;
